{"title":"Python function of the day","markdown":{"yaml":{"title":"Python function of the day","author":"kyle wodehouse","date":"today","numbered":false,"format":{"html":{"self-contained":true,"theme":"pulse"}},"toc":true,"number-sections":true},"headingText":"random sampling","containsRefs":false,"markdown":"\n\n\n## randn\n\nthe first ever matlab function of the day was on week 1 wednesday and it was matlab's `randn`, a function that takes in an array size and returns an array of that size filled with normally distributed random numbers. the python version is `numpy.random.randn` see the documentation [here](https://numpy.org/doc/2.2/reference/random/generated/numpy.random.randn.html), but here are some simple examples\n\n### generating 5 random numbers\n\n### generating 3x3 array of random numbers\n\n## rand\n\nthe second ever matlab function of the day was `rand`, which takes in array dimensions and returns an array of that size with samples from the uniform distribution between 0 and 1. the python version of this is `numpy.random.rand` which is functionally the same. see [documentation](https://numpy.org/doc/stable/reference/random/generated/numpy.random.rand.html)\n\n### generating 3 random numbers\n\n### generating 5x3 array of random numbers\n\n## randi\n\non week 3 friday the matlab function of the day was `randi`, which generates a random integer between 1 and the first parameter `imax`. the closest python function to this is `numpy.random.randint` which takes in a low, high, and array size (as a tuple!!!!) instead of just taking `imax`. see [documentation](https://numpy.org/doc/2.2/reference/random/generated/numpy.random.randint.html) \n\n::: {.callout-note}\nThe interval for the pseudorandom integers is $[\\mathrm{low}, \\mathrm{high})$\n:::\n\n### generating 3 pseudorandom integers between 0 and 100\n\nreally [0,100)\n\n### generating a 3x3 array of pseudorandom integers between 5 and 10\n\nmore specifically [5,10)\n\n# discrete distributions\n\n## binopdf\n\non week 4 friday, `binopdf` was introduced (*during everyone's favorite reoccuring segment*). this is the first funciton where we will start using scipy functions, specifically `scipy.stats.binom.pmf`. see [scipy stats documentation](https://docs.scipy.org/doc/scipy/reference/stats.html) for more distributions and info\n\n::: {.callout-note}\nsince the binomial distribution is discrete, the method called here is `pmf` (probability mass function). scipy is set up in a delicious fashion so the discrete distributions have `pmf` and the continuous have `pdf` (probability distribution function). \n:::\n\n### probability of getting exactly 3 successes out of 3 trials with 50% success\n\n### probability of getting 30 successes out of 300 trials with 10% success\n\n## other discrete distributions\n\na good reference here is the [scipy stats documentation](https://docs.scipy.org/doc/scipy/reference/stats.html#module-scipy.stats). it acknowledges its limitations, but it has everything needed in cheg304 and more\n\n| Distribution    | Scipy        |\n|----------------|--------------|\n| bernoulli      | `bernoulli`    |\n| binomial       | `binom`        |\n| geometric      | `geom`         |\n| hypergeometric | `hypergeom`    |\n| negative binomial | `nbinom`    |\n| poisson        | `poisson`      |\n| uniform        | `randint`      |\n\n\n\n### probability of getting out of jail in monopoly\n\nquestion 2 from spring 2025 cheg304 exam 1. we can do this with the negative binomial or geometric distribution.\n\n::: {.callout-warning}\nscipy swaps the parameters of the negative binomial! for scipy, $k$ is the number of failures and $n$ is the number of successes.\n\n- $n$ is the number of sucesses\n- $k$ is the number of failures\n\nhere's the pmf that scipy is actually evaluating\n\n$$\nf(k) = {k+n-1 \\choose n-1} p^n (1-p)^k\n$$\n\nthis is the same as in table 8.6, but using $k$ instead of $x$ and  $n$ instead of $k$\n:::\n\nfor this, $p = \\frac{1}{6}, k=(0,1,2), n=1$ (in scipy's notation)\n\ncan also use the geometric! this is scipy's geometric pmf\n\n$$\nf(k) = (1-p)^{k-1}p\n$$\n\n# descriptive stats\n\non week 5 wednesday the matlab function of the day became like 1 grillion functions of the day. [here](https://numpy.org/doc/stable/reference/routines.statistics.html) is the numpy statistics documentation. nearly all of these are found here\n\n## sum\n\nthe python version of `sum` is `numpy.sum` (very surprising). this works with lists or series or arrays. \n\n## mean\n\nthe python version of `mean` is `numpy.mean`\n\n## median\n\nfor median use `numpy.median`\n\n## mode\n\nyou'd think `numpy.mode`, but actually this just does not exist. we need to use `scipy.stats.mode`\n\nyou can access just the value of the mode (as `int`, instead of the result output) with the `.mode` method\n\n## std\n\nuse `numpy.std` \n\n::: {.callout-note}\nyou'll likely want to set `ddof=1` to calculate the sample standard deviation. using $n-1$ instead of $n$ is called [bessel's correction](https://en.wikipedia.org/wiki/Bessel%27s_correction).\n:::\n\n## zscore\n\nwhich is really a poor name since these are really t-statistics (they're using a sample mean and sample standard deviation!!!!). again we need to fall back onto scipy and use `scipy.stats.zscore`\n\n::: {.callout-note}\nyou'll likely want to set `ddof=1` here, too.\n:::\n\n## min\n\nuse `numpy.min`\n\n## max\n\nuse `numpy.max`\n\n## range\n\nuse `numpy.ptp`. if you're wondering what ptp stands for, it means peak to peak.\n\n[documentation](https://numpy.org/doc/stable/reference/generated/numpy.ptp.html#numpy.ptp)\n\n## quantile\n\nuse `numpy.quantile`\n\n[documentation](https://numpy.org/doc/stable/reference/generated/numpy.quantile.html)\n\n### the 95th percentile of 50000 samples from z distribution\n\n## skewness, kurtosis\n\nuse `scipy.stats.skew` and `scipy.stats.kurtosis` (or don't)\n\n### skew and kurtosis of 5000 samples from z distribution\n\n\n# sampling\n\non week 6 monday another dump truck of matlab functions was dropped on the slides. all of these will be tackled with scipy in a really beautiful way.\n\n| Distribution | scipy.stats |\n|-------------|-------------|\n| Normal | `norm` |\n| Student's t | `t` |\n| Chi-squared | `chi2` |\n| F | `f` |\n\nall (continuous) distributions in scipy.stats share the same methods:\n\n- `pdf`: probability density function \n- `cdf`: cumulative distribution function\n- `ppf`: percent point function (inverse of cdf)\n- `rvs`: random variates (sampling)\n\n## probability density\n\n### probability density at $t=1.2$ for 10 dof\n\n### probability density at $\\chi^2=20$ for 20 dof\n\n## cumulative density\n\nuse the `cdf` method as mentioned earlier\n\n::: {.callout-note}\nlet $f(x)$ be the probability density function of random variable $x$. for variables that may take on negative values (norm, t), the value of scipy's cdf is\n\n$$\n\\mathrm{cdf(a)} = \\int_{-\\infty}^a f(x) dx\n$$\n\nfor variables that are strictly positive (F, $\\chi^2$)\n\n$$\n\\mathrm{cdf(a)} = \\int_{0}^a f(x) dx\n$$\n\nthis consistency is nice, but it is easy to get confused and use $\\chi^2$ wrong since enszer's table is set up the other way \n:::\n\n### cumulative density for $z=1.0$\n\n### cumulative density for $F=1.5$, dfn=10, dfd=8\n\n\n## inverse functions\n\nas mentioned earlier, the `ppf` method gets the inverse cdf for all of these distributions\n\n### critical t value at $\\alpha=0.05$, 1E6 dof\n\nfor 2-sided so the result looks familiar\n\n### critical $\\chi^2$ for $\\alpha=0.05$, 29 dof\n\n# regression\n\non week 8 friday the `mldivide` was introduced. sadly, there is not a 1 character solution to $\\mathbf{a x = b}$, but there is `numpy.linalg.lstsq`\n\n### first enszer regression example\n\ntaken right from week 8 friday slide 18\n\n::: {.callout-note}\nthis returns more than just the optimal parameters!!!! in order,\n\n1. the least squares solution (what you want)\n2. the sum of the squared residuals\n3. the rank of $\\mathbf{a}$\n4. the singular values from the Singular Value Decomposition of $\\mathbf{a}$\n:::\n\nso really the answers we care about are\n\n# anova\n\n## anova1\n\non week 9 friday, matlab's `anova1` was introduced. one of the python versions of this is `scipy.stats.f_oneway` see the [documentation here](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.f_oneway.html)\n\nif the starting data is just a 5x5 array (like the next example) a little bit of wrangling will need to be done. we want an array with the 5 replicates of each treatment, which means we will need separate arrays for each column. this is why you see me take the transpose of the given 5x5 table and assign each of those rows (which were previously columns) to a variable\n\n\n### one-way anova example problem\n\nas plucked from week 9 wednesday slide 32\n\nsimilar to regression functions, this returns a non-primative type (not a string, int, float, bool). the methods `.statistic` and `.pvalue` will give you access to the F statistic and p-value as float values.\n\nand thats a beautiful float.\n\n## n-way anova\n\nfor transitioning to  n-way anova, it will be useful to start using [pingouin](https://pingouin-stats.org/build/html/index.html) and storing our data as DataFrame types ([pandas](https://pandas.pydata.org/). a data frame is synonomous to a table in Excel. columns may be called by a name and there are really convinient helper functions to rearrange your table.\n\n::: {.callout-warning}\nanaconda installations do not come with pingouin! install it with the following commands\n\n```\nconda activate base\nconda install pingouin -c conda-forge\n```\n:::\n\n### one-way anova example problem with pingouin\n\nI use the `.melt()` method here to turn the table from 5x5 to 25x2 where each row is an individual trial, column 1 is the treatment (the original column), and column 2 is the value.\n\nthis way was super super easy (if you are aware of the `.melt()` helper), and it expands really nicely to n-way anova\n\n### 3-way anova example with pingouin\n\nagain, the data needs wrangled into an appropriate form where each row is a single trial. for convenience i loaded in the data as a `txt` file. small note: this data is from spring 2029 homework 9 question 1. \n\nnow it's a similar process to 1 way\n\n- specify the dependent variable, `dv`\n- specify the columns for ANOVA, `between`\n\n### 2-way anova in class example\n\nthis is from week 9 friday slide 13.\n\nyes, this is the same exact way you'd need to manipulate the table to use minitab, too.\n\n# machine learning day\n\non week 13 friday a few matlab functions for common machine learning algorithms were shared. all of these and more are availible in python through [scikit learn](https://scikit-learn.org/stable/). \n\n## k-means\n\ni'll include a quick k-means clustering example. i'll generate some data that *should* have 3 clusters on an xy plane.\n\nnow importing the appropriate k-means function from `sklearn`. you may be thinking *why does this take in a random state* and the answer is that the points where the centroids are initiated are chosen randomly. this random initialization is also why k-means implimentations will usually take in a parameter to say how many random initializations you want to do (since you only ever converge to a local minimum each initialization)\n\nfor this highly idealized data we do an okay job at clustering with the simple and computationally inexpensive k-means!\n\n# misc\n\nThere are some other helpful functions in scipy and numpy that are similar to matlab functions and very useful in 304 and life outside 304.\n\n## numerical solving\n\nsome useful functions can be found in `scipy.optimize`. namely, `fsolve` (functionally equivalent to matlab's `fsolve`) and `least_squares` which is easier to understand how it works and able to bound solutions. \n\n### numerical solving example\n\nfrom cheg304 spring 2025 homework 6:\n\n> how many samples need taken for 95% confidence interval to be $\\pm 1$, $s=9$\n\nfor this question, we need to iteratively solve this equation for $n$\n\n$$\n1 = t(0.025, n-1) \\frac{s}{\\sqrt{n}}\n$$\n\n## visualization\n\nnearly all python visualizations will use matplotlib in one way or another. the best resource i know is Nicholas Rougiers's python visualization book which is [free on github](https://github.com/rougier/scientific-visualization-book).\n\n### rejection region visualization\n\nfrom homework 6 question 1. this is a nice example because it uses pdf functions from scipy, sets up two axes in one figure, and uses `fill_between` to fill the rejection regions\n\n# final thoughts\n\nhopefully this can bring at least some minescule amount of value to someone wanting to use python functions for cheg304 coursework or related work. \n","srcMarkdownNoYaml":"\n\n# random sampling\n\n## randn\n\nthe first ever matlab function of the day was on week 1 wednesday and it was matlab's `randn`, a function that takes in an array size and returns an array of that size filled with normally distributed random numbers. the python version is `numpy.random.randn` see the documentation [here](https://numpy.org/doc/2.2/reference/random/generated/numpy.random.randn.html), but here are some simple examples\n\n### generating 5 random numbers\n\n### generating 3x3 array of random numbers\n\n## rand\n\nthe second ever matlab function of the day was `rand`, which takes in array dimensions and returns an array of that size with samples from the uniform distribution between 0 and 1. the python version of this is `numpy.random.rand` which is functionally the same. see [documentation](https://numpy.org/doc/stable/reference/random/generated/numpy.random.rand.html)\n\n### generating 3 random numbers\n\n### generating 5x3 array of random numbers\n\n## randi\n\non week 3 friday the matlab function of the day was `randi`, which generates a random integer between 1 and the first parameter `imax`. the closest python function to this is `numpy.random.randint` which takes in a low, high, and array size (as a tuple!!!!) instead of just taking `imax`. see [documentation](https://numpy.org/doc/2.2/reference/random/generated/numpy.random.randint.html) \n\n::: {.callout-note}\nThe interval for the pseudorandom integers is $[\\mathrm{low}, \\mathrm{high})$\n:::\n\n### generating 3 pseudorandom integers between 0 and 100\n\nreally [0,100)\n\n### generating a 3x3 array of pseudorandom integers between 5 and 10\n\nmore specifically [5,10)\n\n# discrete distributions\n\n## binopdf\n\non week 4 friday, `binopdf` was introduced (*during everyone's favorite reoccuring segment*). this is the first funciton where we will start using scipy functions, specifically `scipy.stats.binom.pmf`. see [scipy stats documentation](https://docs.scipy.org/doc/scipy/reference/stats.html) for more distributions and info\n\n::: {.callout-note}\nsince the binomial distribution is discrete, the method called here is `pmf` (probability mass function). scipy is set up in a delicious fashion so the discrete distributions have `pmf` and the continuous have `pdf` (probability distribution function). \n:::\n\n### probability of getting exactly 3 successes out of 3 trials with 50% success\n\n### probability of getting 30 successes out of 300 trials with 10% success\n\n## other discrete distributions\n\na good reference here is the [scipy stats documentation](https://docs.scipy.org/doc/scipy/reference/stats.html#module-scipy.stats). it acknowledges its limitations, but it has everything needed in cheg304 and more\n\n| Distribution    | Scipy        |\n|----------------|--------------|\n| bernoulli      | `bernoulli`    |\n| binomial       | `binom`        |\n| geometric      | `geom`         |\n| hypergeometric | `hypergeom`    |\n| negative binomial | `nbinom`    |\n| poisson        | `poisson`      |\n| uniform        | `randint`      |\n\n\n\n### probability of getting out of jail in monopoly\n\nquestion 2 from spring 2025 cheg304 exam 1. we can do this with the negative binomial or geometric distribution.\n\n::: {.callout-warning}\nscipy swaps the parameters of the negative binomial! for scipy, $k$ is the number of failures and $n$ is the number of successes.\n\n- $n$ is the number of sucesses\n- $k$ is the number of failures\n\nhere's the pmf that scipy is actually evaluating\n\n$$\nf(k) = {k+n-1 \\choose n-1} p^n (1-p)^k\n$$\n\nthis is the same as in table 8.6, but using $k$ instead of $x$ and  $n$ instead of $k$\n:::\n\nfor this, $p = \\frac{1}{6}, k=(0,1,2), n=1$ (in scipy's notation)\n\ncan also use the geometric! this is scipy's geometric pmf\n\n$$\nf(k) = (1-p)^{k-1}p\n$$\n\n# descriptive stats\n\non week 5 wednesday the matlab function of the day became like 1 grillion functions of the day. [here](https://numpy.org/doc/stable/reference/routines.statistics.html) is the numpy statistics documentation. nearly all of these are found here\n\n## sum\n\nthe python version of `sum` is `numpy.sum` (very surprising). this works with lists or series or arrays. \n\n## mean\n\nthe python version of `mean` is `numpy.mean`\n\n## median\n\nfor median use `numpy.median`\n\n## mode\n\nyou'd think `numpy.mode`, but actually this just does not exist. we need to use `scipy.stats.mode`\n\nyou can access just the value of the mode (as `int`, instead of the result output) with the `.mode` method\n\n## std\n\nuse `numpy.std` \n\n::: {.callout-note}\nyou'll likely want to set `ddof=1` to calculate the sample standard deviation. using $n-1$ instead of $n$ is called [bessel's correction](https://en.wikipedia.org/wiki/Bessel%27s_correction).\n:::\n\n## zscore\n\nwhich is really a poor name since these are really t-statistics (they're using a sample mean and sample standard deviation!!!!). again we need to fall back onto scipy and use `scipy.stats.zscore`\n\n::: {.callout-note}\nyou'll likely want to set `ddof=1` here, too.\n:::\n\n## min\n\nuse `numpy.min`\n\n## max\n\nuse `numpy.max`\n\n## range\n\nuse `numpy.ptp`. if you're wondering what ptp stands for, it means peak to peak.\n\n[documentation](https://numpy.org/doc/stable/reference/generated/numpy.ptp.html#numpy.ptp)\n\n## quantile\n\nuse `numpy.quantile`\n\n[documentation](https://numpy.org/doc/stable/reference/generated/numpy.quantile.html)\n\n### the 95th percentile of 50000 samples from z distribution\n\n## skewness, kurtosis\n\nuse `scipy.stats.skew` and `scipy.stats.kurtosis` (or don't)\n\n### skew and kurtosis of 5000 samples from z distribution\n\n\n# sampling\n\non week 6 monday another dump truck of matlab functions was dropped on the slides. all of these will be tackled with scipy in a really beautiful way.\n\n| Distribution | scipy.stats |\n|-------------|-------------|\n| Normal | `norm` |\n| Student's t | `t` |\n| Chi-squared | `chi2` |\n| F | `f` |\n\nall (continuous) distributions in scipy.stats share the same methods:\n\n- `pdf`: probability density function \n- `cdf`: cumulative distribution function\n- `ppf`: percent point function (inverse of cdf)\n- `rvs`: random variates (sampling)\n\n## probability density\n\n### probability density at $t=1.2$ for 10 dof\n\n### probability density at $\\chi^2=20$ for 20 dof\n\n## cumulative density\n\nuse the `cdf` method as mentioned earlier\n\n::: {.callout-note}\nlet $f(x)$ be the probability density function of random variable $x$. for variables that may take on negative values (norm, t), the value of scipy's cdf is\n\n$$\n\\mathrm{cdf(a)} = \\int_{-\\infty}^a f(x) dx\n$$\n\nfor variables that are strictly positive (F, $\\chi^2$)\n\n$$\n\\mathrm{cdf(a)} = \\int_{0}^a f(x) dx\n$$\n\nthis consistency is nice, but it is easy to get confused and use $\\chi^2$ wrong since enszer's table is set up the other way \n:::\n\n### cumulative density for $z=1.0$\n\n### cumulative density for $F=1.5$, dfn=10, dfd=8\n\n\n## inverse functions\n\nas mentioned earlier, the `ppf` method gets the inverse cdf for all of these distributions\n\n### critical t value at $\\alpha=0.05$, 1E6 dof\n\nfor 2-sided so the result looks familiar\n\n### critical $\\chi^2$ for $\\alpha=0.05$, 29 dof\n\n# regression\n\non week 8 friday the `mldivide` was introduced. sadly, there is not a 1 character solution to $\\mathbf{a x = b}$, but there is `numpy.linalg.lstsq`\n\n### first enszer regression example\n\ntaken right from week 8 friday slide 18\n\n::: {.callout-note}\nthis returns more than just the optimal parameters!!!! in order,\n\n1. the least squares solution (what you want)\n2. the sum of the squared residuals\n3. the rank of $\\mathbf{a}$\n4. the singular values from the Singular Value Decomposition of $\\mathbf{a}$\n:::\n\nso really the answers we care about are\n\n# anova\n\n## anova1\n\non week 9 friday, matlab's `anova1` was introduced. one of the python versions of this is `scipy.stats.f_oneway` see the [documentation here](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.f_oneway.html)\n\nif the starting data is just a 5x5 array (like the next example) a little bit of wrangling will need to be done. we want an array with the 5 replicates of each treatment, which means we will need separate arrays for each column. this is why you see me take the transpose of the given 5x5 table and assign each of those rows (which were previously columns) to a variable\n\n\n### one-way anova example problem\n\nas plucked from week 9 wednesday slide 32\n\nsimilar to regression functions, this returns a non-primative type (not a string, int, float, bool). the methods `.statistic` and `.pvalue` will give you access to the F statistic and p-value as float values.\n\nand thats a beautiful float.\n\n## n-way anova\n\nfor transitioning to  n-way anova, it will be useful to start using [pingouin](https://pingouin-stats.org/build/html/index.html) and storing our data as DataFrame types ([pandas](https://pandas.pydata.org/). a data frame is synonomous to a table in Excel. columns may be called by a name and there are really convinient helper functions to rearrange your table.\n\n::: {.callout-warning}\nanaconda installations do not come with pingouin! install it with the following commands\n\n```\nconda activate base\nconda install pingouin -c conda-forge\n```\n:::\n\n### one-way anova example problem with pingouin\n\nI use the `.melt()` method here to turn the table from 5x5 to 25x2 where each row is an individual trial, column 1 is the treatment (the original column), and column 2 is the value.\n\nthis way was super super easy (if you are aware of the `.melt()` helper), and it expands really nicely to n-way anova\n\n### 3-way anova example with pingouin\n\nagain, the data needs wrangled into an appropriate form where each row is a single trial. for convenience i loaded in the data as a `txt` file. small note: this data is from spring 2029 homework 9 question 1. \n\nnow it's a similar process to 1 way\n\n- specify the dependent variable, `dv`\n- specify the columns for ANOVA, `between`\n\n### 2-way anova in class example\n\nthis is from week 9 friday slide 13.\n\nyes, this is the same exact way you'd need to manipulate the table to use minitab, too.\n\n# machine learning day\n\non week 13 friday a few matlab functions for common machine learning algorithms were shared. all of these and more are availible in python through [scikit learn](https://scikit-learn.org/stable/). \n\n## k-means\n\ni'll include a quick k-means clustering example. i'll generate some data that *should* have 3 clusters on an xy plane.\n\nnow importing the appropriate k-means function from `sklearn`. you may be thinking *why does this take in a random state* and the answer is that the points where the centroids are initiated are chosen randomly. this random initialization is also why k-means implimentations will usually take in a parameter to say how many random initializations you want to do (since you only ever converge to a local minimum each initialization)\n\nfor this highly idealized data we do an okay job at clustering with the simple and computationally inexpensive k-means!\n\n# misc\n\nThere are some other helpful functions in scipy and numpy that are similar to matlab functions and very useful in 304 and life outside 304.\n\n## numerical solving\n\nsome useful functions can be found in `scipy.optimize`. namely, `fsolve` (functionally equivalent to matlab's `fsolve`) and `least_squares` which is easier to understand how it works and able to bound solutions. \n\n### numerical solving example\n\nfrom cheg304 spring 2025 homework 6:\n\n> how many samples need taken for 95% confidence interval to be $\\pm 1$, $s=9$\n\nfor this question, we need to iteratively solve this equation for $n$\n\n$$\n1 = t(0.025, n-1) \\frac{s}{\\sqrt{n}}\n$$\n\n## visualization\n\nnearly all python visualizations will use matplotlib in one way or another. the best resource i know is Nicholas Rougiers's python visualization book which is [free on github](https://github.com/rougier/scientific-visualization-book).\n\n### rejection region visualization\n\nfrom homework 6 question 1. this is a nice example because it uses pdf functions from scipy, sets up two axes in one figure, and uses `fill_between` to fill the rejection regions\n\n# final thoughts\n\nhopefully this can bring at least some minescule amount of value to someone wanting to use python functions for cheg304 coursework or related work. \n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","number-sections":true,"toc":true,"self-contained":true,"output-file":"pythonfunctionoftheday.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","theme":"cosmo","title":"Python function of the day","author":"kyle wodehouse","date":"today","numbered":false},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}